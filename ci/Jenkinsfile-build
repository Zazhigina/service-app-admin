#!groovy

// import shared library
@Library("dsoLibrary@master") _

// populate variables from folder
withFolderProperties{
    RH_REGISTRY_TRUST = "${env.RH_REGISTRY_TRUST}"
    RH_REGISTRY_TRUST_CRED_ID = "${env.RH_REGISTRY_TRUST_CRED_ID}"
    RH_REGISTRY_DEV = "${env.RH_REGISTRY_DEV}"
    RH_REGISTRY_DEV_CRED_ID = "${env.RH_REGISTRY_DEV_CRED_ID}"
    QUAY_REGISTRY_TRUST = "${env.QUAY_REGISTRY_TRUST}"
    QUAY_REGISTRY_TRUST_CRED_ID = "${env.QUAY_REGISTRY_TRUST_CRED_ID}"
    QUAY_REGISTRY_DEV = "${env.QUAY_REGISTRY_DEV}"
    QUAY_REGISTRY_DEV_CRED_ID = "${env.QUAY_REGISTRY_DEV_CRED_ID}"
    REGISTRY_TRUST = "${env.REGISTRY_TRUST}"
    REGISTRY_TRUST_CRED_ID = "${env.REGISTRY_TRUST_CRED_ID}"
    REGISTRY_DEV = "${env.REGISTRY_DEV}"
    REGISTRY_DEV_CRED_ID = "${env.REGISTRY_DEV_CRED_ID}"
    PROJECT_ID = "${env.PROJECT_ID}"
}

if (BUILD_ENVIRONMENT == 'trust') {
    REGISTRY = REGISTRY_TRUST
    REGISTRY_CRED_ID = REGISTRY_TRUST_CRED_ID
    RH_REGISTRY = RH_REGISTRY_TRUST
    RH_REGISTRY_CRED_ID = RH_REGISTRY_TRUST_CRED_ID
    QUAY_REGISTRY = QUAY_REGISTRY_TRUST
    QUAY_REGISTRY_CRED_ID = QUAY_REGISTRY_TRUST_CRED_ID
} else if (BUILD_ENVIRONMENT == 'dev') {
    REGISTRY = REGISTRY_DEV
    REGISTRY_CRED_ID = REGISTRY_DEV_CRED_ID
    RH_REGISTRY = RH_REGISTRY_DEV
    RH_REGISTRY_CRED_ID = RH_REGISTRY_DEV_CRED_ID
    QUAY_REGISTRY = QUAY_REGISTRY_DEV
    QUAY_REGISTRY_CRED_ID = QUAY_REGISTRY_DEV_CRED_ID
}

def scan_repos = [
    ("$OCP_APP_NAME" as String): "$BRANCH"
]

pipeline {
    parameters {
        string(name: 'email', defaultValue: 'Zaytsev.OI@gazprom-neft.ru,Stronin.IYu@omsk.gazprom-neft.ru', description: 'Email address for reports', trim: true)
        booleanParam(name: 'SAST', defaultValue: false, description: 'Run SAST code check [TRUST]')
        booleanParam(name: 'SCA', defaultValue: false, description: 'Run CodeScoring check [TRUST]')
        booleanParam(name: 'CSec', defaultValue: false, description: 'Run Container Security check [TRUST]')
        choice(name: 'TYPE', choices: ["luntry", "clair"], description: 'luntry or clair')
    }

    agent {
        label "$BUILD_ENVIRONMENT"
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '100', artifactNumToKeepStr: '100'))
    }

    environment {
        GIT_COMMIT_SHORT = sh(
                script: "printf \$(git rev-parse --short ${GIT_COMMIT})",
                returnStdout: true
        )
    }

    stages {
        stage("Set build name") {
            steps {
                script {
                    buildSetter()
                }
            }
        }

        stage('SAST scan') {
            when {
                equals(actual: BUILD_ENVIRONMENT, expected: 'trust')
                equals(actual: params.SAST, expected: true)
            }
            steps {
                doSastCheck "manualWithParameters", [sast_lang: "Java", "repos_for_scan": scan_repos, "sast_generate_reports": true, "sast_generate_reports_email_list": params.email]
            }
        }

        stage('CodeScoring check') {
            when {
                equals(actual: BUILD_ENVIRONMENT, expected: 'trust')
                equals(actual: params.SCA, expected: true)
            }
            steps {
                script {
                    def result = doScaCheck('git_url': "ssh://alm-itsk.gazprom-neft.local:8180/TFS/GPN/${PROJECT_ID}/_git/${OCP_APP_NAME}",
                                            'git_branch': "${BRANCH}",
                                            'email': params.email,
                                            'report_archive_name': "${OCP_APP_NAME}-${GIT_COMMIT_SHORT}_SCA.zip")
                    println("=== pipeline scan result ===\npassed: $result.passed\nreport: $result.report\nmessage: $result.message")
                    if (!result.passed) {
                        error('SCA сканирование завершено. Обнаружены критические уязвимости')
                    }
                }
            }
        }

        stage("Docker registry login") {
            steps {
                doDocker("login", ["registryCred": "$REGISTRY_CRED_ID",
                                   "registry": "$REGISTRY"])
                doDocker("login", ["registryCred": "$RH_REGISTRY_CRED_ID",
                                   "registry": "$RH_REGISTRY"])
                doDocker("login", ["registryCred": "$QUAY_REGISTRY_CRED_ID",
                                   "registry": "$QUAY_REGISTRY"])
            }
        }

        stage("Docker build image") {
            steps {
                doDocker("build", ["registry": "$REGISTRY",
                                   "registry_path": "$PROJECT_ID",
                                   "image_name": "$OCP_APP_NAME",
                                   "image_tag": "$GIT_COMMIT_SHORT",
                                   "dockerfileName": "$DOCKERFILE_NAME",
                                   "additionalArgs": ""])
            }
        }

        stage("Docker push image") {
            steps {
                doDocker("push", ["registry": "$REGISTRY",
                                  "registry_path": "$PROJECT_ID",
                                  "image_name": "$OCP_APP_NAME",
                                  "image_tag": "$GIT_COMMIT_SHORT"])
            }
        }

        stage ("Container Security check") {
            when {
                equals(actual: BUILD_ENVIRONMENT, expected: 'trust')
                equals(actual: params.CSec, expected: true)
            }
            steps {
                script {
                    doContainerSecurityCheck(["registry": "$REGISTRY",
                                              "image": "$PROJECT_ID/$OCP_APP_NAME:$GIT_COMMIT_SHORT",
                                              "mail": params.email,
                                              "csec_type": params.TYPE,
                                              "report_archive_name": "${OCP_APP_NAME}-${GIT_COMMIT_SHORT}_CSec"
                    ])
                }
            }
        }
    }
}
